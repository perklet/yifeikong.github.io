<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Yifei Kong | articles in the "计算机" category | Page 10</title>
    <link rel="shortcut icon" type="image/png" href="/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link href="/feed/atom-all.xml" type="application/atom+xml" rel="alternate" title="Yifei Kong Full Atom Feed" />
    <link href="/feed/rss-all.xml" type="application/rss+xml" rel="alternate" title="Yifei Kong Full RSS Feed" />
    <link href="/feed/atom.xml" type="application/atom+xml" rel="alternate" title="Yifei Kong Atom Feed" />
    <link href="/feed/rss.xml" type="application/rss+xml" rel="alternate" title="Yifei Kong RSS Feed" />
    <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/pygments.css" type="text/css" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Yifei Kong" />
</head>
<body>
    <header>
        <nav>
            <ul>

                <li class="ephemeral selected"><a href="/category/ji-suan-ji/page/10/index.html">计算机</a></li>
                <li><a href="/">Home</a></li>
                <li><a href="https://github.com/">GitHub</a></li>
                <li><a href="/tags">Tags</a></li>
                <li><a href="/categories">Categories</a></li>
                <li><a href="/archives">Archives</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="/">Yifei Kong</a></h1>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Apr 13, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/du-the-anatomy-of-a-large-scale-hypertextual-web-search-engine.html" rel="bookmark" title="Permanent Link to &quot;读《The Anatomy of a large-scale hypertextual Web search engine》&quot;">读《The Anatomy of a large-scale hypertextual Web search engine》</a>
                </h2>

                
                

                <p>Google 在1997年的论文[1], 到现在(2017)的话, 已经有二十年的历史了, 然而对于编写一个小的搜索引擎, 依然有好多具有指导意义的地方.</p>
<p>The Anatomy of a large-scale hypertextual Web search engine 这篇论文应该是一片总结性质的论文, 而且论文并没有多少的关于数据结构等的实现细节. 只是大体描绘了一下架构.</p>
<h1>Google的算法</h1>
<p>首先, Google大量使用了在超文本也就是网页中存在的结构, 也就是锚文本和链接. 还有就是如何有效的处理在网页上, 所有人都可以任意发布任何文字的问题, Google在这片文章里给的解决方案是PageRank.</p>
<p>在20年前, 主要问题是, 网页已经开始快速增长, 然而当时的所有搜索引擎给出的结果只是搜索结果的数量也增长了, 却没能把最相关的结果放在首页. 因为人们并不会因为给出结果多而去多看几页, 所以这样的结果是不可取的. 在设计Google的过程中, Google还考虑了随着web规模的增长, 会对现有的体系造成的影响以及如何应对.</p>
<p>Google 还表达了对当时的搜索引擎都是商业化的, 因而一些诸如用户查询之类的结果无法共学术应用的情况表达了不满. (呵呵, Google这不是打自己的脸么)</p>
<p>对于 PageRank 算法, 提到了简单的公式:</p>
<p><img alt="" src="https://ws1.sinaimg.cn/large/006tKfTcly1fqazehy4zdj30im02mmxd.jpg"></p>
<p>其中Tx表示的是指向A页面的所有页面, C表示的是一个页面上所有的外链. 对于这个公式的解释是这样的 …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/du-the-anatomy-of-a-large-scale-hypertextual-web-search-engine.html">posted at 05:48</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                    &nbsp;<a href="/tag/pa-chong.html" class="tags">爬虫</a>
                </div>
            </article>            <h4 class="date">Apr 13, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/pa-chong-ip-feng-jin-yu-fan-feng-jin.html" rel="bookmark" title="Permanent Link to &quot;爬虫 IP 封禁与反封禁&quot;">爬虫 IP 封禁与反封禁</a>
                </h2>

                
                

                <p>反爬虫的核心在于区分开正常用户访问和恶意爬虫用户。来源 IP 是访问很重要的一个特征，我们可以从来源 IP 的角度来做出不少反爬虫策略。</p>
<ul>
<li>是否是代理IP</li>
<li>是否是民用IP</li>
<li>IP 地理信息</li>
</ul>
<p>一般来说，大规模的爬虫我们都会放到服务器上去跑，搭建代理集群也会在服务器上，而正常用户的IP地址则来自家用IP范围内。这就给反爬虫的一方提供了便利，对于来自数据中心的请求可以直接限制访问甚至直接屏蔽掉，而对于家用的IP地址则宽容一些。</p>
<p>下面我们来看几个实例</p>
<h1>直接爬取网站</h1>
<p>一般正常用户的页面访问量很小，如果发现某个 IP 的访问量特别大，那么肯定是爬虫，直接封禁即可，或者每次都需要输入验证码访问。</p>
<p>IP 被封禁后一般不会被解封，或者需要很长时间，这时候只有两种思路，要么降低频率，更改自己的行为特征，避免被封，要么更换 IP。一般来说，不管怎样更改自己的行为，访问量还是很难降下来的，这时候只能换一个 IP 继续爬。</p>
<h1>使用代理网站提供的代理IP</h1>
<p>一些黑客会使用端口扫描器扫描互联网上的开放代理，然后免费或者付费提供给其他用户使用，比如下面这些网站：</p>
<p><img alt="免费代理" src="https://ws2.sinaimg.cn/large/006tNbRwly1fu6vtfrvgvj30zy0pgn3y.jpg"></p>
<p>但是这些网站的代理中能直接使用的可能不到10%，而且失效时间很短。所以要使用这些代理 IP …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/pa-chong-ip-feng-jin-yu-fan-feng-jin.html">posted at 00:26</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                    &nbsp;<a href="/tag/pa-chong.html" class="tags">爬虫</a>
                </div>
            </article>            <h4 class="date">Apr 12, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/pv-zai-linux-xia-cha-kan-ming-ling-zhi-xing-jin-du.html" rel="bookmark" title="Permanent Link to &quot;pv - 在 Linux 下查看命令执行进度&quot;">pv - 在 Linux 下查看命令执行进度</a>
                </h2>

                
                

                <p>pv 是 Pipe Viewer 的缩写，也就是管道查看器。挡在命令行执行命令的时候，可以通过使用 pv 来指导当前的进度。</p>
<h1>使用</h1>
<h2>替换 cat</h2>
<p>比如你要把一个日志打包好下载：</p>
<div class="highlight"><pre><span></span><span class="c">% gzip -c access.log &gt; access.log.gz</span>
</pre></div>


<p>可以改成</p>
<div class="highlight"><pre><span></span><span class="c">% cat access.log | gzip &gt; access.log.gz</span>
</pre></div>


<p>使用 pv</p>
<div class="highlight"><pre><span></span><span class="c">% pv access.log | gzip &gt; access.log.gz</span>
<span class="mi">611</span><span class="n">MB</span> <span class="mi">0</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">11</span> <span class="p">[</span><span class="mf">58.3</span><span class="n">MB</span><span class="o">/</span><span class="n">s</span><span class="p">]</span> <span class="p">[=</span><span class="o">&gt;</span>      <span class="p">]</span> <span class="mi">15</span><span class="c">% ETA 0 …</span></pre></div>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/pv-zai-linux-xia-cha-kan-ming-ling-zhi-xing-jin-du.html">posted at 07:41</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/hou-duan.html" class="tags">后端</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>            <h4 class="date">Apr 11, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/yi-css-xuan-ze-qi-bei-wang-lu-cheatsheet.html" rel="bookmark" title="Permanent Link to &quot;[译] CSS 选择器备忘录（cheatsheet）&quot;">[译] CSS 选择器备忘录（cheatsheet）</a>
                </h2>

                
                

                <p>这两天打算写写爬虫，准备用 css 选择器来抽取内容，翻译了<a href="http://butlerccwebdev.net/support/css-selectors-cheatsheet.html">一篇文章</a>，正好复习一下，这篇文章遵守 CC-BY-NC-SA 协议。</p>
<p>大多数的 web 开发者首先学会了 CSS。因为给 HTML 元素写样式规则的元素选择器都很容易理解和记忆。经过一点点练习之后，就会发现成组的 CSS 表达式非常的有必要，比如使用一个逗号分隔开选择器，就可以把同一个样式属性附加到不同的多个元素了。</p>
<p>使用标签选择器和分组的选择器当然也有不足，那就是他们会应用到所有的标签。很快你就会意识到有时候需要给一个特定的元素加上样式。对于大多数开发者来说，最简单的选择当然是使用 class 和 id 选择器了。但是很遗憾的是这样下去的话，整个页面就会充满各种奇奇怪怪的类了。</p>
<p>除了不管的给 HTML 添加纯粹用于应用样式的 class 和 id 之外，你也可以考虑使用高级的 CSS 选择器来给指定元素应用样式。高级的选择器大致可以分类为上下文选择器、属性选择器、伪元素选择器和伪类选择器。</p>
<h1>元素选择器</h1>
<p>元素选择器把样式应用到所有选中元素上，也是被使用最广泛的选择器 …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/yi-css-xuan-ze-qi-bei-wang-lu-cheatsheet.html">posted at 09:51</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/css.html" class="tags">CSS</a>
                    &nbsp;<a href="/tag/da-qian-duan.html" class="tags">大前端</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>            <h4 class="date">Apr 11, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/mysql-ji-chu-zhi-shi-6-join.html" rel="bookmark" title="Permanent Link to &quot;mysql 基础知识(6) - Join&quot;">mysql 基础知识(6) - Join</a>
                </h2>

                
                

                <p>看到网上<a href="https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/">有篇文章</a>用韦恩图来讲解了一下 SQL 的 join 操作，但是感觉举的例子似乎不太实际，遂自己写了一篇，图是从那篇文章里面盗的（逃</p>
<p>假设我们有下面两张表，上边的是表 user，下边的是 package，表示每个用户对应的包裹</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Luke</td>
</tr>
<tr>
<td>2</td>
<td>Leia</td>
</tr>
<tr>
<td>3</td>
<td>Anakin</td>
</tr>
<tr>
<td>4</td>
<td>Padem</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>id</th>
<th>content</th>
<th>user_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>droid</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>lightsaber</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>blaster</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>R2D2</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>创建这两个表的语句分别是：</p>
<div class="highlight"><pre><span></span>create table user (id integer, name string …</pre></div>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/mysql-ji-chu-zhi-shi-6-join.html">posted at 02:16</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/shu-ju-ku.html" class="tags">数据库</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>            <h4 class="date">Apr 09, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/go-yu-yan-he-pa-chong.html" rel="bookmark" title="Permanent Link to &quot;Go 语言和爬虫&quot;">Go 语言和爬虫</a>
                </h2>

                
                

                <h1>爬虫的算法</h1>
<h2>广度遍历</h2>
<p>如果把每一个页面看做一个节点，把每个链接看做一个有向边，那么网页之间就构成了一个有向图。爬虫的核心就是对这个图做一个广度优先的遍历：</p>
<div class="highlight"><pre><span></span>func breadthFirst(visit func(item, string) []string, worklist []string) {
    seen := make(map[string]bool)
    for len(worklist) &gt; 0 {
        items := worklist
        worklist = nil
        for _, items := range items {
            if !seen[item] {
                seen[item] = true
                worklist = append(worklist, visit(item)...)
            }
        }
    }
}
</pre></div>


<h2>终止条件</h2>
<p>如果我们面对的是一个有限的图，那么用广度遍历一定可以停下来。但是对于互联网来说，甚至于对于某个网站来说，页面的数量都可能是无限的 …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/go-yu-yan-he-pa-chong.html">posted at 08:10</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/golang.html" class="tags">golang</a>
                    &nbsp;<a href="/tag/bian-cheng-yu-yan.html" class="tags">编程语言</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                    &nbsp;<a href="/tag/pa-chong.html" class="tags">爬虫</a>
                </div>
            </article>            <h4 class="date">Apr 09, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/mysql-ji-chu-zhi-shi-5-ju-he-yu-ju-group-by.html" rel="bookmark" title="Permanent Link to &quot;mysql 基础知识(5) - 聚合语句(group by)&quot;">mysql 基础知识(5) - 聚合语句(group by)</a>
                </h2>

                
                

                <p><code>Group by</code> 用来按照某一列或者某几列的值聚合数据。<code>group by x</code> 按照 x 相同的值聚合，<code>group by x, y</code> 按照 x 和 y 都相同的值聚合。而查询的列要么是聚合的列，要么应该通过聚合函数来选取一列。而且所有的 null 会被聚合成一行</p>
<p>比如说下面的数据表中</p>
<p><img alt="" src="https://daks2k3a4ib2z.cloudfront.net/589e47d231ee752554896f1f/58dc686fb5bd4cf41639ef71_Screen%20Shot%202017-03-29%20at%207.07.17%20PM.png"></p>
<div class="highlight"><pre><span></span>-- How many countries are in each continent?
select
  continent
  , count(*)
from 
  countries
group by 
  continent
</pre></div>


<p>执行查询可以得到每个洲的国家的数量。</p>
<h1>过滤</h1>
<p>在 SQL 中，Where 子句是在 group 子句之前运行的，所以我们无法通过 where …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/mysql-ji-chu-zhi-shi-5-ju-he-yu-ju-group-by.html">posted at 01:48</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/shu-ju-ku.html" class="tags">数据库</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>            <h4 class="date">Apr 08, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/wan-quan-li-jie-sql-de-nei-zai-luo-ji.html" rel="bookmark" title="Permanent Link to &quot;完全理解 SQL 的内在逻辑&quot;">完全理解 SQL 的内在逻辑</a>
                </h2>

                
                

                <p>太多的程序员认为SQL像是洪水猛兽一样。它是少有的几种声明式的语言，和其他的命令似的面向对象的甚至函数使得语言大相径庭。
我每天都会写SQL而且在我的开源项目中大量的使用SQL，因此我非常地想要把SQL的美展现给你们这些还在挣扎着使用它的渣渣们。下面的教程适合</p>
<ol>
<li>使用过SQL但是从来没有完全理解他的人</li>
<li>很了解SQL，但是从来没有思考过他的语法的人</li>
<li>想要把SQL交给其他人的人</li>
</ol>
<p>这个教程将会这关注SELECT语句，其他的DML将会在另一篇文章中介绍</p>
<h1>SQL是声明式的</h1>
<p>首先要记住，声明式。唯一的一种范式就是你可以只是声明你想要的结果就得到了他。而不是告诉你的电脑怎样去把这个结果计算出来，不错吧？</p>
<div class="highlight"><pre><span></span>Select first_name, last_name FROM employees WHERE salary &amp;gt; 100000
</pre></div>


<p>很简单，你不需要关心employee的记录是存在哪里的，你只想要知道那些薪水还不错的人。</p>
<p>如此简单，那么问题在哪里呢？问题在于我们大部分时候是在按照命令式的编程思维在思考,比如“机器，干这个，然后干那个，但是在这之前检查一下，如果是这样或者那样就不行”。这其中包括了存储临时结果在变量里，循环，迭代，调用函数等等。</p>
<p>忘掉那些东西，思考如何声明东西，而不是告诉机器怎样去计算。</p>
<h1>SQL语法的顺序有些问题</h1>
<p>常见的混乱的来源可能是SQL语法并不是按他们的执行顺序来排序的，词法（Lexical …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/wan-quan-li-jie-sql-de-nei-zai-luo-ji.html">posted at 14:44</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/shu-ju-ku.html" class="tags">数据库</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>            <h4 class="date">Apr 04, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/tiao-biao-skiplist.html" rel="bookmark" title="Permanent Link to &quot;跳表（skiplist）&quot;">跳表（skiplist）</a>
                </h2>

                
                

                <p>平衡二叉树可以实现 O(logn) 的查找复杂度。跳表可以实现相当于平衡二叉树的复杂度查询数据，而代码实现比较简单。在 Redis 中，zset 就用到了 skiplist。</p>
<p>跳表是用<strong>并连的链表</strong>来实现的查询结构</p>
<p><img alt="" src="https://ws3.sinaimg.cn/large/006tNc79gy1fq102txkvvj30hs07haaf.jpg"></p>
<ul>
<li>每个节点包含的指针的层数是由一个随机数决定的。</li>
<li>跳表的时间复杂度和平衡二叉树相同，但是在实现上要简单很多。</li>
<li>跳表是有序的，跳跃表的特点就是有序的，所以对于一些有序类型的数据，比如整数，日期这种，用跳跃表可以进行范围查找。</li>
<li>在构建跳跃表和查询跳跃的复杂度一致，所以也比较适合于在线的实时索引查询，可以来一个文档，一边查找就一边知道要如何进行插入操作了。</li>
<li>保存到磁盘和从磁盘载入也比较简单，因为本质上是几个链表，所以保存的时候可以按照数组的方式分别保存几个数组就可以了。</li>
</ul>
<h1>一些优化</h1>
<p>空间优化，把底层的表放到硬盘里，影响增加删除节点的效率</p>
<p><img alt="" src="https://ws4.sinaimg.cn/large/006tNc79gy1fq1043qhraj30hs06i3zn.jpg"></p>
<p>时间优化，用数组代替链表，可以使用二分查找而非遍历</p>
<p><img alt="" src="https://ws4.sinaimg.cn/large/006tNc79gy1fq104leytgj30hs06j0tf.jpg"></p>
<p>对于类似时间这种数据，比如24小时对应1440分钟对应86400秒钟</p>
<p>甚至可以固定直接用索引随机访问</p>
<p><img alt="" src="https://ws3.sinaimg.cn/large/006tNc79gy1fq106sqt91j30hs06j758.jpg"></p>
<h1>实现</h1>
<p>https://github.com/begeekmyfriend/skiplist/blob/master/skiplist …</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/tiao-biao-skiplist.html">posted at 06:36</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/suan-fa.html" class="tags">算法</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>            <h4 class="date">Apr 04, 2018</h4>

            <article class="post">
                <h2 class="title">
                    <a href="/posts/python-argparse-ku-de-shi-yong.html" rel="bookmark" title="Permanent Link to &quot;Python Argparse 库的使用&quot;">Python Argparse 库的使用</a>
                </h2>

                
                

                <h2>基本用法</h2>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--verbosity&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;increase output verbosity&quot;</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>
</pre></div>


<p>两种不同的参数模式， <code>positional</code>，<code>optional arguments</code>，感觉之间的区别有点像 args 和 kwargs</p>
<h2>subcommand</h2>
<p>Actually, the argparse module is not ok with subcommand, mannually parse the first command and then pass the rest to argparse</p>
<h3>add_argument …</h3>
                <div class="clear"></div>

                <div class="info">
                    <a href="/posts/python-argparse-ku-de-shi-yong.html">posted at 06:23</a>
                    &nbsp;&middot;&nbsp;<a href="/category/ji-suan-ji.html" rel="tag">计算机</a>
                    &nbsp;&middot;
                    &nbsp;<a href="/tag/python.html" class="tags">Python</a>
                    &nbsp;<a href="/tag/bian-cheng-yu-yan.html" class="tags">编程语言</a>
                    &nbsp;<a href="/tag/ji-suan-ji.html" class="tags">计算机</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">

                    <a href="/page/9" class="prev_page">&larr;&nbsp;Previous</a>
                    <a href="/page/11" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 10 of 30</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
                &middot;
                <a href="/feed/atom-all.xml" rel="alternate">Atom Feed</a>
                &middot;
                <a href="/feed/rss-all.xml" rel="alternate">Rss Feed</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
</body>
</html>